"""
Example integration of Database Manager and SQL Validator with Text-to-SQL system.

This demonstrates how to safely execute SQL queries generated by ML models.
"""

from pathlib import Path
from typing import Dict, Any, Optional, Tuple
import pandas as pd

from database_manager import DatabaseManager
from sql_validator import SQLValidator, format_validation_report


class SafeTextToSQLExecutor:
    """
    Safe executor for Text-to-SQL systems.

    Validates and executes SQL queries generated by ML models with safety checks.
    """

    def __init__(self, db_path: str, read_only: bool = True):
        """
        Initialize the executor.

        Args:
            db_path: Path to SQLite database
            read_only: If True, only allow SELECT queries (default: True)
        """
        self.db_path = Path(db_path)
        self.read_only = read_only
        self.db_manager = DatabaseManager(db_path, read_only=read_only)
        self.validator = SQLValidator(self.db_manager.get_schema(), read_only=read_only)

    def execute_generated_query(
        self,
        natural_language: str,
        generated_sql: str,
        return_full_report: bool = False
    ) -> Dict[str, Any]:
        """
        Execute a SQL query generated from natural language.

        Args:
            natural_language: Original natural language question
            generated_sql: SQL query generated by the model
            return_full_report: If True, return detailed validation report

        Returns:
            Dictionary containing:
            - success: bool
            - results: DataFrame (if successful)
            - error: str (if failed)
            - validation_report: dict (if return_full_report=True)
        """
        result = {
            'natural_language': natural_language,
            'generated_sql': generated_sql,
            'success': False,
            'results': None,
            'error': None
        }

        # Step 1: Validate the query
        is_valid, errors = self.validator.validate(generated_sql)

        if not is_valid:
            # Collect all error messages
            error_messages = [
                f"{e.error_type}: {e.message}"
                for e in errors
                if e.severity == 'error'
            ]
            result['error'] = '; '.join(error_messages)

            if return_full_report:
                result['validation_report'] = {
                    'is_valid': is_valid,
                    'errors': [
                        {'type': e.error_type, 'message': e.message, 'severity': e.severity}
                        for e in errors
                    ]
                }
            return result

        # Step 2: Check for warnings
        warnings = [e for e in errors if e.severity == 'warning']
        if warnings and return_full_report:
            result['warnings'] = [
                {'type': w.error_type, 'message': w.message}
                for w in warnings
            ]

        # Step 3: Execute the query
        try:
            results_df = self.db_manager.execute_query(generated_sql)
            result['success'] = True
            result['results'] = results_df
            result['row_count'] = len(results_df)

            # Get query metadata
            if return_full_report:
                metadata = self.validator.get_query_metadata(generated_sql)
                result['query_metadata'] = metadata

        except Exception as e:
            result['error'] = f"Execution error: {str(e)}"

        return result

    def get_schema_context(self) -> str:
        """
        Get database schema information as text for prompt context.

        Returns:
            String representation of database schema suitable for ML model prompts
        """
        schema = self.db_manager.get_schema()

        context_lines = ["Database Schema:"]

        for table_name, table_info in schema['tables'].items():
            context_lines.append(f"\nTable: {table_name}")

            # Columns
            context_lines.append("Columns:")
            for col in table_info['columns']:
                pk = " (PRIMARY KEY)" if col['primary_key'] else ""
                nullable = " NULL" if col['nullable'] else " NOT NULL"
                context_lines.append(f"  - {col['name']}: {col['type']}{nullable}{pk}")

            # Foreign keys
            if table_info['foreign_keys']:
                context_lines.append("Foreign Keys:")
                for fk in table_info['foreign_keys']:
                    context_lines.append(
                        f"  - {fk['column']} -> {fk['references_table']}.{fk['references_column']}"
                    )

        return "\n".join(context_lines)

    def get_sample_data_context(self, num_samples: int = 3) -> str:
        """
        Get sample data from all tables for context.

        Args:
            num_samples: Number of sample rows per table

        Returns:
            String representation of sample data
        """
        tables = self.db_manager.get_table_names()
        context_lines = ["Sample Data:"]

        for table in tables:
            context_lines.append(f"\n{table} (sample rows):")
            sample_df = self.db_manager.get_sample_data(table, limit=num_samples)
            context_lines.append(sample_df.to_string(index=False))

        return "\n".join(context_lines)

    def close(self):
        """Close database connection."""
        self.db_manager.close()

    def __enter__(self):
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        self.close()


def example_usage():
    """Demonstrate usage with example Text-to-SQL scenarios."""

    db_path = Path(__file__).parent.parent / "data" / "databases" / "sample_university.db"

    with SafeTextToSQLExecutor(db_path, read_only=True) as executor:

        print("=" * 80)
        print("TEXT-TO-SQL SAFE EXECUTION EXAMPLES")
        print("=" * 80)

        # Example queries with natural language and generated SQL
        examples = [
            {
                'nl': "Show me all students with GPA above 3.5",
                'sql': "SELECT name, major, gpa FROM students WHERE gpa > 3.5 ORDER BY gpa DESC"
            },
            {
                'nl': "Which professors teach Computer Science courses?",
                'sql': """
                    SELECT DISTINCT p.name, p.department
                    FROM professors p
                    JOIN courses c ON p.id = c.professor_id
                    WHERE c.department = 'Computer Science'
                """
            },
            {
                'nl': "How many students are enrolled in each major?",
                'sql': """
                    SELECT major, COUNT(*) as student_count
                    FROM students
                    GROUP BY major
                    ORDER BY student_count DESC
                """
            },
            {
                'nl': "Find students taking the most courses",
                'sql': """
                    SELECT s.name, s.major, COUNT(e.course_id) as num_courses
                    FROM students s
                    JOIN enrollments e ON s.id = e.student_id
                    GROUP BY s.id, s.name, s.major
                    ORDER BY num_courses DESC
                    LIMIT 5
                """
            },
            # Example with error - invalid table
            {
                'nl': "Show me all teachers",  # Wrong terminology
                'sql': "SELECT * FROM teachers"  # Table doesn't exist
            },
            # Example with safety violation
            {
                'nl': "Delete all failing students",
                'sql': "DELETE FROM students WHERE gpa < 2.0"
            }
        ]

        for i, example in enumerate(examples, 1):
            print(f"\n{'=' * 80}")
            print(f"Example {i}")
            print(f"{'=' * 80}")
            print(f"Natural Language: {example['nl']}")
            print(f"Generated SQL: {example['sql'].strip()}")
            print()

            # Execute with safety checks
            result = executor.execute_generated_query(
                example['nl'],
                example['sql'],
                return_full_report=True
            )

            if result['success']:
                print("✓ Execution Successful")
                print(f"Rows returned: {result['row_count']}")
                print("\nResults:")
                print(result['results'].to_string(index=False))

                if 'query_metadata' in result:
                    print(f"\nQuery Complexity: {result['query_metadata']['complexity']}")

            else:
                print("✗ Execution Failed")
                print(f"Error: {result['error']}")

            if 'warnings' in result:
                print("\nWarnings:")
                for warning in result['warnings']:
                    print(f"  - {warning['message']}")


def example_schema_context_for_prompt():
    """Show how to get schema context for ML model prompts."""

    db_path = Path(__file__).parent.parent / "data" / "databases" / "sample_university.db"

    with SafeTextToSQLExecutor(db_path) as executor:
        print("\n" + "=" * 80)
        print("SCHEMA CONTEXT FOR ML MODEL PROMPT")
        print("=" * 80)

        # Get schema context
        schema_context = executor.get_schema_context()
        print(schema_context)

        print("\n" + "=" * 80)
        print("SAMPLE DATA CONTEXT")
        print("=" * 80)

        # Get sample data
        sample_context = executor.get_sample_data_context(num_samples=2)
        print(sample_context)

        print("\n" + "=" * 80)
        print("COMPLETE PROMPT EXAMPLE")
        print("=" * 80)

        prompt = f"""You are a SQL query generator. Given a natural language question, generate a valid SQLite query.

{schema_context}

{sample_context}

Question: Show me students with GPA above 3.5 majoring in Computer Science
SQL Query:"""

        print(prompt)


if __name__ == "__main__":
    print("Running Text-to-SQL Safe Execution Examples\n")
    example_usage()
    example_schema_context_for_prompt()

    print("\n" + "=" * 80)
    print("INTEGRATION GUIDE")
    print("=" * 80)
    print("""
To integrate with your Text-to-SQL model:

1. Initialize the executor:
   executor = SafeTextToSQLExecutor('path/to/database.db', read_only=True)

2. Get schema context for your model's prompt:
   schema_context = executor.get_schema_context()
   sample_data = executor.get_sample_data_context()

3. Generate SQL from natural language using your model:
   generated_sql = your_model.generate(question, schema_context)

4. Safely execute with validation:
   result = executor.execute_generated_query(question, generated_sql)

5. Check results:
   if result['success']:
       df = result['results']
       # Process results
   else:
       error = result['error']
       # Handle error, maybe regenerate query

Key Benefits:
- Automatic validation prevents execution of invalid SQL
- Read-only mode prevents accidental data modification
- Schema checking catches table/column name errors
- Parameterization support prevents SQL injection
- Detailed error messages help with model debugging
    """)
